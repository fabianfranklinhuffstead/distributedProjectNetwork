package models.Server;

import controllers.GlobalResources;
import models.BoatDataHandle;
import models.Server.Communication.*;
import views.Displays.DispNetwork.NetworkConsoleDisplay;

import javax.swing.*;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.ConnectException;
import java.net.Socket;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.time.LocalDateTime;


//Workstation client which uses transmission control protocol. The use of threads are shown  
public class WorkstationClient {

	// Messages out here
    private final NetworkConsoleDisplay _NetworkConsoleDisplay;

    // Socket here
    private volatile Socket _Socket;

    // Output stream
    private volatile ObjectOutputStream _ObjectOutputStream;

    // Input stream
    private volatile ObjectInputStream _ObjectInputStream;

    // Network not running message
    private volatile boolean _NetworkKilledMessage = false;

    // Request thread here
    private Thread _ThreadRequested;

    // Type of map requested
    private String _MapRequestedType = "";

    // The map response is set to idle waiting for the workstation and network to make actions
    private volatile boolean _MapResponseIdle = false;

    // Checks if socket is closed for workstations to connect
    private volatile boolean _SocketClosed = false;
    
    // Actual map response from network
    private SystemMessageResponse _WaitingMapResponse;

    // Previous error message
    private volatile String _PreviousErrorMessage = "";
    
    // Waiting for opposing player request
    private final Runnable OpposingPlayerRequest = () ->
    {
        SystemMessage networkreponse;
        try {
            _MapResponseIdle = true;
            _WaitingMapResponse = null;
            networkreponse = (SystemMessage) _ObjectInputStream.readObject();

            if (networkreponse.getType() == SystemMessageType.PLAYERFOUNDINITIATEGAME) {
                _MapRequestedType = "";
                _WaitingMapResponse = (SystemMessageResponse) networkreponse;
                _MapResponseIdle = false;

                WorkstationLog("Network server: Player assigned - " + Integer.toString(_WaitingMapResponse.get_AssignmentForPlayer()));
                //Now back to the promise callback waiting for method
                SwingUtilities.invokeLater(() ->
                        GlobalResources.MainControl.PromiseCallbackForOtherPlayer());


            } else {
                _MapResponseIdle = false;

                if (networkreponse.getType() == SystemMessageType.NETWORKDOWNTIME) {
                    _NetworkKilledMessage = true;
                    WorkstationLog("Network server: Network is down try to reconnect");
                    _Socket.close();
                    _Socket = null;
                } else {
                    WorkstationLog("Network server: ERROR. Message from server: " + Integer.toString(networkreponse.getType()));
                }
            }

        } catch (SocketException se) {
            if (!_SocketClosed)
                WorkstationLog("Network server: socket is down.");
        } catch (Exception e) {
            if (!_SocketClosed)
                WorkstationLog("Network server: ERROR. Message from server:" + e.getMessage());
        }
    };

    // Previous boat status message
    private volatile BoatStatusMessage _PreviousBoatStatusMessage;
    
    // Listens to data handle incoming updates
    private BoatDataHandle _boatRemoteToHandleIncomingUpdates;
    
    // Incoming updates from the boat 
    private volatile boolean _IncomingUpdatesFromBoat = false;
    
    //Status thread listens
    private Thread _StatusThread;
    
    //Update thread runs and listens for incoming updates
    private final Runnable UpdateThread = () ->
    {
        while (_IncomingUpdatesFromBoat && !_NetworkKilledMessage) {
            SystemMessage message = null;
            try {
                message = (SystemMessage) _ObjectInputStream.readObject();

            } catch (Exception e) {
                message = null;
                // Listens for incoming updates from boat and network killed message
                if (_IncomingUpdatesFromBoat && !_NetworkKilledMessage) {
                    e.printStackTrace();
                    _IncomingUpdatesFromBoat = false;
                    SwingUtilities.invokeLater(() -> GlobalResources.MainControl.get_RuntimeEngine().AutoGeneratedErrorNetworkMessage(e.getMessage()));
                }
            }


            if (message != null) {
                // If boat movement changes handles incoming updates and call backs on updating messages
                if (message.getType() == SystemMessageType.BOATMOVEMENTCHANGE) {
                    BoatStatusMessage updateMessage = (BoatStatusMessage) message;
                    _boatRemoteToHandleIncomingUpdates.boatUpdateCallback(updateMessage);
                }

                //if boat crash call back and update incoming updates
                if (message.getType() == SystemMessageType.BOATCRASH) {
                    _IncomingUpdatesFromBoat = false;
                    SwingUtilities.invokeLater(() -> _boatRemoteToHandleIncomingUpdates.boatCrashCallback());
                }

                //if workstation/player disconnects drops the current run session
                if (message.getType() == SystemMessageType.PLAYERDISCONNECT) {
                    _IncomingUpdatesFromBoat = false;
                    SwingUtilities.invokeLater(() -> GlobalResources.MainControl.get_RuntimeEngine().OtherPlayerDownSession());
                }

                //If server down message received then stop listening and notify RuntimeEngine
                if (message.getType() == SystemMessageType.NETWORKDOWNTIME) {
                    _NetworkKilledMessage = true;
                    _IncomingUpdatesFromBoat = false;
                    SwingUtilities.invokeLater(() -> GlobalResources.MainControl.get_RuntimeEngine().ServerDownCallback());
                }
            }
        }
    };
    
    // Status push to network of workstations boats information updates if network is not down
    private final Runnable StatusPush = () ->
    {
        if (!_NetworkKilledMessage) {
            if (_IncomingUpdatesFromBoat) {
                if (_PreviousBoatStatusMessage != null) {
                    //Pushing out status and checking previous
                    if (!PushOutput(_PreviousBoatStatusMessage)) {
                        //if error set updates to false 
                        _IncomingUpdatesFromBoat = false;
                        SwingUtilities.invokeLater(() -> GlobalResources.MainControl.get_RuntimeEngine().AutoGeneratedErrorNetworkMessage(_PreviousErrorMessage));
                    }
                }
            }
        }
    };

    
    // sends and receives information from transmission control protocol components and messages/status
    public WorkstationClient(NetworkConsoleDisplay networkConsoleDisplay) {
        _NetworkConsoleDisplay = networkConsoleDisplay;
    }

    //Push output stream returns false on error
    private synchronized boolean PushOutput(SystemMessage message)
    {
        boolean result = false;
        try {
            _ObjectOutputStream.writeObject(message);
            result = true;
        } catch (Exception e) {
            _PreviousErrorMessage = e.getMessage().toString();
            WorkstationLog("Error sending output: " + e.getMessage());
        }
        return result;
    }

    //Shuts the output and returns message
    private synchronized String ShutOutput()
    {
        if (_ObjectOutputStream != null) {
            try {
                _ObjectOutputStream.close();
            } catch (Exception e) {
                return e.getMessage();
            }
        }
        return "";
    }

    //Opens the output stream and returns message
    private synchronized String OpenOutput() {
        try {
            _ObjectOutputStream = new ObjectOutputStream(_Socket.getOutputStream());
        } catch (Exception e) {
            return e.getMessage();
        }
        return "";
    }

    //Connecting to the network server
    public boolean NetworkServerConnecting(String NetworkAddress, int portValueNumber) {
        boolean result = true;

        if (TryShutDownClientConnection(true)) {
            try {
                _Socket = new Socket(NetworkAddress, portValueNumber);
                _Socket.setSoTimeout(0);
                WorkstationLog("Network server connecting SUCCESS.");

                //I/O streams
                String isOpenOutOk = OpenOutput();
                if (isOpenOutOk.equals("")) {
                    _ObjectInputStream = new ObjectInputStream(_Socket.getInputStream());

                    //Greetings message
                    if (PushOutput(new SystemMessage(SystemMessageType.GREETINGS))) {
                        WorkstationLog("GREETINGS.");
                        _NetworkKilledMessage = false;
                        _SocketClosed = false;
                    } else {
                        result = false;
                        WorkstationLog("Test message failed: " + _PreviousErrorMessage);
                    }
                } else {
                    result = false;
                    WorkstationLog("Error with output streams. Closing socket connection");
                    _Socket.close();
                    _Socket = null;
                    WorkstationLog("Dropped connection attempt");
                }

            } catch (UnknownHostException uh) {
                _Socket = null;
                result = false;
                WorkstationLog("ERRROR: Host not known. Please check sysetem.");
            } catch (ConnectException ce) {
                _Socket = null;
                result = false;
                // BAD CONNECTION network server will not allow connection
                WorkstationLog("Network server: BAD CONNECTION");
            } catch (IOException e) {
                _Socket = null;
                result = false;
                e.printStackTrace();
            }

        } else {
            result = false;
        }

        return result;
    }

    // Calls other player
    public void CallOtherPlayer(String MapType, int selectedboatTypeIndex) {
        if (_ThreadRequested != null) {
            if (_ThreadRequested.isAlive()) {
                if (_MapRequestedType == MapType) {
                    // Returns here no need as sever is calling back i.e. promise
                    return;
                } else {
                    //interrupts requested thread and to allow for change in map type
                    WorkstationLog("Map type cancelled: \"" + _MapRequestedType);
                    _ThreadRequested.interrupt();

                    //Search cancel
                    SystemMessage cancel = new SystemMessage(SystemMessageType.CANCELSEARCHPLAYER);

                    if (!PushOutput(cancel)) {
                        WorkstationLog("Cancelling map request BAD ERROR:" + _PreviousErrorMessage);
                    }
                }
            }
        }

        NetworkMessageRequest mapmessage = new NetworkMessageRequest(SystemMessageType.SEARCHINGFOROTHERPLAYER);
        mapmessage.set_MapName(MapType);
        mapmessage.set_boatImageFileIndex(selectedboatTypeIndex);
        _MapRequestedType = MapType;

        if (!PushOutput(mapmessage)) {
            WorkstationLog("Other player request BAD ERROR: " + _PreviousErrorMessage);
        } else {
            WorkstationLog("Searching other player map selection \"" + MapType);
            //Request required here
            _ThreadRequested = new Thread(OpposingPlayerRequest);
            _ThreadRequested.start();
        }
    }

    // sends exit response before closing Network server
    public boolean TryShutDownClientConnection(boolean EXIT) {
        boolean result = true;
        if (_Socket != null) {
            if (!_Socket.isClosed()) {


                if (EXIT) {
                    if (PushOutput(new SystemMessage(SystemMessageType.EXIT)))
                        WorkstationLog("EXIT.");
                    else
                        WorkstationLog("ERROR: BAD CONNECTION EXIT FAILED.");
                }

                //on closed sockets and map response idles interrupt thread
                if (_MapResponseIdle) {
                    _MapResponseIdle = false;
                    _SocketClosed = true;
                    _ThreadRequested.interrupt();
                }


                String ShutdownConfirm = ShutOutput();
                if (!ShutdownConfirm.equals(""))
                    WorkstationLog("ERROR: Shutdown output stream failed.");


                try {
                    _ObjectInputStream.close();
                } catch (Exception e) {
                    result = false;
                }
                try {
                    _Socket.close();
                } catch (Exception e) {
                    result = false;
                    WorkstationLog("ERROR: Shutdown socket failed.");
                }


                _Socket = null;
            }
        }
        return result;
    }

    // Player to network session cancelled message
    public void PlayerToNetworkCanceledSession() {
        if (_Socket != null) {
            if (!_Socket.isClosed()) {
                if (!PushOutput(new SystemMessage(SystemMessageType.PLAYERDISCONNECT)))
                    WorkstationLog("ERROR: Shutdown message failed.");
            }
        }
    }

    // Gets local time, displays workstation and message
    private synchronized void WorkstationLog(String text) {

        Runnable run = new Runnable() {
            @Override
            public void run() {
                if (_NetworkConsoleDisplay != null) {
                    final LocalDateTime now = LocalDateTime.now();
                    String time = now.toLocalTime().toString();

                    final String sender = "WORKSTATION: ";

                    String message = time + ", " + sender + text;
                    _NetworkConsoleDisplay.LogMessages(message);
                }
            }
        };
        SwingUtilities.invokeLater(run);
    }

    // Returns system Message response
    public SystemMessageResponse get_WaitingMapResponse() {
        return _WaitingMapResponse;
    }


    // Push boat status to allow data handle to update
    public void StatusMessage(BoatStatusMessage message) {
        _PreviousBoatStatusMessage = message;
        Thread messenger = new Thread(StatusPush);
        messenger.start();
    }

    // Call back object when new status from incomming boat available
    public void NotifyMeOfboatUpdates(BoatDataHandle boatDataHandle) {
        _boatRemoteToHandleIncomingUpdates = boatDataHandle;
    }

    // Switch listeners of for boat
    public void SwitchUpdateListenersOff() {
        _IncomingUpdatesFromBoat = false;
        if (_StatusThread != null) {
            if (_StatusThread.isAlive()) {
                _StatusThread.interrupt();
            }
            _StatusThread = null;
        }
    }

    // Listens to boat in game changes
    public void ListenToBoatGameChanges() {
        if (_boatRemoteToHandleIncomingUpdates != null) {
            _IncomingUpdatesFromBoat = true;
            _StatusThread = new Thread(UpdateThread);
            _StatusThread.start();
        }
    }

    //Sends boat crashed message
    public void SendboatCrashedMessage() {
        SystemMessage message = new SystemMessage(SystemMessageType.BOATCRASH);
        _IncomingUpdatesFromBoat = false;

        if (!PushOutput(message))
            WorkstationLog("Boat image failed to load: BAD ERROR");
    }


    //Returns true or false for map being idle
    public boolean is_MapResponseIdle() {
        return _MapResponseIdle;
    }

    // Promise waiting for update from other workstations
    public void PromiseWaitingForOtherPlayer() {
        WorkstationLog("Waiting... Please wait...");
    }
}
